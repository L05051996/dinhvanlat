import telebot
import requests
import json
import os
import sqlite3
import logging
import time
import random
from datetime import datetime, timezone, timedelta
from textblob import TextBlob
from dotenv import load_dotenv
from tenacity import retry, stop_after_attempt, wait_fixed

# Load environment variables
load_dotenv()
TOKEN = os.getenv("TELEGRAM_TOKEN", "7109961635:AAHY8JfCuOxQedZZWFZOZNP_o1fzjOytDGQ")
WEATHER_API_KEY = os.getenv("WEATHER_API_KEY", "your_openweathermap_api_key")
ALPHA_VANTAGE_API_KEY = os.getenv("ALPHA_VANTAGE_API_KEY", "your_alpha_vantage_api_key")
LLM_API_KEY = os.getenv("LLM_API_KEY", "your_llm_api_key")
LLM_API_URL = os.getenv("LLM_API_URL", "https://api.x.ai/grok")

# Configure logging
logging.basicConfig(filename='bot.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Initialize bot
bot = telebot.TeleBot(TOKEN)
weather_cache = {}
market_cache = {}
user_context = {}
PREF_FILE = "user_preferences.json"
VN_TIMEZONE = timezone(timedelta(hours=7))  # Vietnam timezone (+07)

# Initialize SQLite database
def init_db():
    conn = sqlite3.connect('chat_history.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS messages
                 (user_id TEXT, message TEXT, response TEXT, timestamp TEXT)''')
    conn.commit()
    conn.close()

init_db()

# Cleanup old messages
def cleanup_old_messages(days=30):
    conn = sqlite3.connect('chat_history.db')
    c = conn.cursor()
    cutoff = (datetime.now(VN_TIMEZONE) - timedelta(days=days)).strftime("%Y-%m-%d %H:%M:%S")
    c.execute("DELETE FROM messages WHERE timestamp < ?", (cutoff,))
    conn.commit()
    conn.close()

# Load/save user preferences
def load_preferences():
    if os.path.exists(PREF_FILE):
        with open(PREF_FILE, 'r') as f:
            return json.load(f)
    return {}

def save_preferences(prefs):
    with open(PREF_FILE, 'w') as f:
        json.dump(prefs, f)

# Save/retrieve conversation history
def save_message(user_id, message, response):
    conn = sqlite3.connect('chat_history.db')
    c = conn.cursor()
    timestamp = datetime.now(VN_TIMEZONE).strftime("%Y-%m-%d %H:%M:%S")
    c.execute("INSERT INTO messages (user_id, message, response, timestamp) VALUES (?, ?, ?, ?)",
              (user_id, message, response, timestamp))
    conn.commit()
    conn.close()

def get_recent_messages(user_id, limit=5):
    conn = sqlite3.connect('chat_history.db')
    c = conn.cursor()
    c.execute("SELECT message, response FROM messages WHERE user_id = ? ORDER BY timestamp DESC LIMIT ?",
              (user_id, limit))
    messages = c.fetchall()
    conn.close()
    return messages

# Intent detection with Vietnamese support
def extract_intent(text):
    text = text.lower()
    if any(word in text for word in ["time", "clock", "hour", "gio", "thoi gian"]):
        return "time"
    if any(word in text for word in ["weather", "forecast", "thoi tiet", "du bao"]):
        return "weather"
    if any(word in text for word in ["joke", "funny", "laugh", "vui", "cuoi"]):
        return "joke"
    if any(word in text for word in ["market", "stock", "crypto", "forex", "price", "thi truong", "co phieu", "tien dien tu", "gia"]):
        return "market"
    return "general"

# LLM integration
@retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
def get_llm_response(prompt, user_id):
    headers = {
        "Authorization": f"Bearer {LLM_API_KEY}",
        "Content-Type": "application/json"
    }
    context = get_recent_messages(user_id, limit=3)
    context_text = "\n".join([f"User: {msg}\nBot: {resp}" for msg, resp in context])
    full_prompt = f"Context:\n{context_text}\n\nUser: {prompt}\nBot:"
    
    payload = {
        "prompt": full_prompt,
        "max_tokens": 500,
        "temperature": 0.7
    }
    
    try:
        response = requests.post(LLM_API_URL, headers=headers, json=payload)
        response.raise_for_status()
        result = response.json()
        return result.get("choices", [{}])[0].get("text", "Xin l·ªói, tui kh√¥ng hi·ªÉu l·∫Øm! üòÖ")
    except Exception as e:
        logging.error(f"LLM API error: {str(e)}")
        return "√îi, tui h∆°i lag! üò¥ Th·ª≠ l·∫°i nha!"

# Weather API
@retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
def get_weather(city):
    if city in weather_cache and time.time() - weather_cache[city][1] < 600:
        return weather_cache[city][0]
    
    url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={WEATHER_API_KEY}&units=metric"
    try:
        response = requests.get(url).json()
        if response.get("cod") != 200:
            logging.warning(f"Weather API error for city {city}: {response.get('message')}")
            return f"Kh√¥ng t√¨m th·∫•y th·ªùi ti·∫øt cho {city}. üòÖ"
        weather = response["weather"][0]["description"]
        temp = response["main"]["temp"]
        result = f"{weather}, {temp}¬∞C"
        weather_cache[city] = (result, time.time())
        return result
    except Exception as e:
        logging.error(f"Error fetching weather data: {str(e)}")
        return f"L·ªói l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt! üò¥ Th·ª≠ l·∫°i nha!"

# Market API
@retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
def get_market_data(symbol, market_type="stock"):
    cache_key = f"{symbol}_{market_type}"
    if cache_key in market_cache and time.time() - market_cache[cache_key][1] < 300:
        return market_cache[cache_key][0]
    
    try:
        if market_type == "crypto":
            url = f"https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids={symbol.lower()}"
            response = requests.get(url).json()
            if not response:
                return f"Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho {symbol}. üòÖ"
            data = response[0]
            result = (
                f"Ti·ªÅn ƒëi·ªán t·ª≠: {data['name']} ({data['symbol'].upper()})\n"
                f"Gi√°: ${data['current_price']:.2f}\n"
                f"Thay ƒë·ªïi 24h: {data['price_change_percentage_24h']:.2f}%\n"
                f"V·ªën h√≥a: ${data['market_cap']:,.0f}"
            )
        else:
            if market_type == "forex":
                url = f"https://www.alphavantage.co/query?function=FX_DAILY&from_symbol={symbol[:3]}&to_symbol={symbol[3:]}&apikey={ALPHA_VANTAGE_API_KEY}"
            else:
                url = f"https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol={symbol}&apikey={ALPHA_VANTAGE_API_KEY}"
            
            response = requests.get(url).json()
            if "Error Message" in response:
                return f"Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho {symbol}. üòÖ"
            if "Note" in response and "rate limit" in response["Note"].lower():
                return f"API b·∫≠n r·ªìi! üò¥ Th·ª≠ l·∫°i sau v√†i ph√∫t nha!"
            
            if market_type == "forex":
                data = response["Time Series FX (Daily)"][list(response["Time Series FX (Daily)"].keys())[0]]
                result = (
                    f"C·∫∑p ngo·∫°i h·ªëi: {symbol[:3]}/{symbol[3:]}\n"
                    f"ƒê√≥ng c·ª≠a: {float(data['4. close']):.4f}\n"
                    f"Cao: {float(data['2. high']):.4f}\n"
                    f"Th·∫•p: {float(data['3. low']):.4f}"
                )
            else:
                data = response["Global Quote"]
                result = (
                    f"C·ªï phi·∫øu: {symbol}\n"
                    f"Gi√°: ${float(data['05. price']):.2f}\n"
                    f"Thay ƒë·ªïi: {float(data['09. change']):.2f} ({float(data['10. change percent'].strip('%')):.2f}%)\n"
                    f"Kh·ªëi l∆∞·ª£ng: {int(data['06. volume']):,}"
                )
        
        market_cache[cache_key] = (result, time.time())
        return result
    except Exception as e:
        logging.error(f"Error fetching market data for {symbol}: {str(e)}")
        return f"√îi, l·ªói r·ªìi! üòÖ Th·ª≠ l·∫°i sau nha!"

# Joke function
def get_joke():
    jokes = [
        "Sao th·ªã tr∆∞·ªùng ch·ª©ng kho√°n l·∫°i s·ª•p? V√¨ n√≥ say margin! üìâ",
        "T·∫°i sao ƒë√°m m√¢y ƒëi tr·ªã li·ªáu t√¢m l√Ω? V√¨ n√≥ c√≥ qu√° nhi·ªÅu m·ªëi quan h·ªá 'gi√¥ng b√£o'! üå©Ô∏è",
        "L·∫≠p tr√¨nh vi√™n th√≠ch s√°ng hay t·ªëi? T·ªëi, v√¨ s√°ng thu h√∫t b·ªç! üêû",
        "Bitcoin m√† ngh√®o th√¨ g·ªçi l√† g√¨? D√¢n ƒÉn xin ƒëi·ªán t·ª≠! üòú"
    ]
    return random.choice(jokes)

# Sentiment analysis
def analyze_sentiment(text):
    blob = TextBlob(text)
    sentiment = blob.sentiment.polarity
    if sentiment > 0.1:
        return "positive", random.choice([
            "Tr·ªùi ∆°i, b·∫°n vui th·∫ø! C√≥ g√¨ hay ho ƒëang x·∫£y ra h·∫£? üòÑ",
            "H√¥m nay b·∫°n ph·∫•n kh·ªüi gh√™! K·ªÉ tui nghe ƒëi! üöÄ"
        ])
    elif sentiment < -0.1:
        return "negative", random.choice([
            "√îi, sao nghe bu·ªìn v·∫≠y? Mu·ªën tui k·ªÉ chuy·ªán c∆∞·ªùi cho vui kh√¥ng? üòä",
            "H√¥m nay h∆°i xu·ªëng mood h·∫£? Th·ª≠ h·ªèi tui v·ªÅ th·ªùi ti·∫øt ho·∫∑c th·ªã tr∆∞·ªùng xem! üìà"
        ])
    else:
        return "neutral", random.choice([
            "B√¨nh th∆∞·ªùng th√¥i h·∫£? Mu·ªën tui khu·∫•y ƒë·ªông t√≠ kh√¥ng? üòé",
            "Chill th·∫ø! H·ªèi tui g√¨ ƒëi, th·ªùi ti·∫øt hay c·ªï phi·∫øu? ü§ô"
        ])

# Bot commands
@bot.message_handler(commands=['start'])
def start(message):
    user_name = message.from_user.first_name
    response = f"Xin ch√†o {user_name}! Tui l√† bot th√¥ng minh, bi·∫øt t·ª´ th·ªùi ti·∫øt, ch·ª©ng kho√°n ƒë·∫øn tr·∫£ l·ªùi m·ªçi c√¢u h·ªèi! G√µ /help ƒë·ªÉ kh√°m ph√° nha! üòé"
    save_message(str(message.from_user.id), message.text, response)
    bot.reply_to(message, response)

@bot.message_handler(commands=['help', 'tro_giup'])
def help_command(message):
    help_text = (
        "Tui l√† bot si√™u x·ªãn! üòé C√≥ th·ªÉ l√†m:\n"
        "/start - Ch√†o b·∫°n\n"
        "/help ho·∫∑c /tro_giup - Xem h∆∞·ªõng d·∫´n\n"
        "/weather ho·∫∑c /thoitiet <th√†nh ph·ªë> - Xem th·ªùi ti·∫øt\n"
        "/market ho·∫∑c /thitruong <m√£> [stock|crypto|forex] - Xem th·ªã tr∆∞·ªùng\n"
        "/joke ho·∫∑c /cuoi - Nghe chuy·ªán c∆∞·ªùi\n"
        "/history ho·∫∑c /lich_su - Xem l·ªãch s·ª≠ tr√≤ chuy·ªán\n"
        "/feedback ho·∫∑c /phan_hoi <text> - G·ª≠i ph·∫£n h·ªìi\n"
        "/preferences ho·∫∑c /ca_nhan - Xem s·ªü th√≠ch\n"
        "/reset_preferences ho·∫∑c /xoa_ca_nhan - X√≥a s·ªü th√≠ch\n"
        "/status ho·∫∑c /trang_thai - Ki·ªÉm tra tr·∫°ng th√°i bot\n"
        "H·ªèi g√¨ c≈©ng ƒë∆∞·ª£c, tui tr·∫£ l·ªùi h·∫øt! üòÑ"
    )
    save_message(str(message.from_user.id), message.text, help_text)
    bot.reply_to(message, help_text)

@bot.message_handler(commands=['weather', 'thoitiet'])
def weather_command(message):
    user_id = str(message.from_user.id)
    try:
        city = message.text.split(maxsplit=1)[1]
        user_context[user_id] = {"last_city": city}
        preferences = load_preferences()
        if user_id not in preferences:
            preferences[user_id] = {"favorites": []}
        favorites = preferences[user_id].get("favorites", [])
        if city not in favorites:
            favorites.append(city)
        preferences[user_id]["favorites"] = favorites
        save_preferences(preferences)
        
        weather_info = get_weather(city)
        response = f"{city}: {weather_info}. Cool kh√¥ng? üòÑ"
        save_message(user_id, message.text, response)
        bot.reply_to(message, response)
    except IndexError:
        preferences = load_preferences()
        if user_id in preferences and preferences[user_id].get("favorites", []):
            city = preferences[user_id]["favorites"][-1]
            weather_info = get_weather(city)
            response = f"Ch∆∞a ch·ªçn th√†nh ph·ªë, tui check {city} n√®: {weather_info}. Th·ª≠ c√°i kh√°c? üòé"
        else:
            response = "Cho tui m·ªôt th√†nh ph·ªë ƒëi, v√≠ d·ª•: /thoitiet H√† N·ªôi! üòÑ"
        save_message(user_id, message.text, response)
        bot.reply_to(message, response)

@bot.message_handler(commands=['market', 'thitruong'])
def market_command(message):
    user_id = str(message.from_user.id)
    try:
        parts = message.text.split(maxsplit=2)
        if len(parts) < 2:
            raise IndexError
        symbol = parts[1].upper()
        market_type = parts[2].lower() if len(parts) > 2 else "stock"
        
        if market_type not in ["stock", "crypto", "forex"]:
            response = "Sai lo·∫°i r·ªìi! Ch·ªâ c√≥ 'stock', 'crypto', ho·∫∑c 'forex' th√¥i nha! üòÖ"
        else:
            market_data = get_market_data(symbol, market_type)
            response = f"{market_data}. Xem c√°i kh√°c kh√¥ng? üìà"
            
            preferences = load_preferences()
            if user_id not in preferences:
                preferences[user_id] = {"favorites": []}
            favorites = preferences[user_id].get("favorites", [])
            if {"symbol": symbol, "type": market_type} not in favorites:
                favorites.append({"symbol": symbol, "type": market_type})
            preferences[user_id]["favorites"] = favorites
            save_preferences(preferences)
            user_context[user_id] = {"last_favorite": {"symbol": symbol, "type": market_type}}
        
        save_message(user_id, message.text, response)
        bot.reply_to(message, response)
    except IndexError:
        preferences = load_preferences()
        if user_id in preferences and preferences[user_id].get("favorites", []):
            last_favorite = preferences[user_id]["favorites"][-1]
            market_data = get_market_data(last_favorite["symbol"], last_favorite["type"])
            response = f"Ch∆∞a ch·ªçn m√£, tui check {last_favorite['symbol']} ({last_favorite['type']}) n√®: {market_data}. Th·ª≠ c√°i kh√°c? üòé"
        else:
            response = "Cho tui m√£ v·ªõi lo·∫°i ƒëi, v√≠ d·ª•: /thitruong AAPL stock ho·∫∑c /thitruong BTC crypto! üòÑ"
        save_message(user_id, message.text, response)
        bot.reply_to(message, response)

@bot.message_handler(commands=['joke', 'cuoi'])
def joke_command(message):
    joke = get_joke()
    response = f"{joke}. Mu·ªën nghe th√™m kh√¥ng? üòú"
    save_message(str(message.from_user.id), message.text, response)
    bot.reply_to(message, response)

@bot.message_handler(commands=['history', 'lich_su'])
def history_command(message):
    user_id = str(message.from_user.id)
    messages = get_recent_messages(user_id)
    if messages:
        response = "L·ªãch s·ª≠ tr√≤ chuy·ªán c·ªßa b·∫°n:\n"
        for msg, resp in messages:
            response += f"B·∫°n: {msg}\nTui: {resp}\n\n"
    else:
        response = "Ch∆∞a c√≥ l·ªãch s·ª≠ tr√≤ chuy·ªán n√®! üòÖ"
    save_message(user_id, message.text, response)
    bot.reply_to(message, response)

@bot.message_handler(commands=['feedback', 'phan_hoi'])
def feedback_command(message):
    user_id = str(message.from_user.id)
    try:
        feedback = message.text.split(maxsplit=1)[1]
        logging.info(f"Feedback from {user_id}: {feedback}")
        response = "C·∫£m ∆°n ph·∫£n h·ªìi c·ªßa b·∫°n! Tui s·∫Ω c·ªë g·∫Øng t·ªët h∆°n nha! üòÑ"
    except IndexError:
        response = "Cho tui √Ω ki·∫øn ƒëi, v√≠ d·ª•: /phan_hoi Bot x·ªãn l·∫Øm! üòé"
    save_message(user_id, message.text, response)
    bot.reply_to(message, response)

@bot.message_handler(commands=['preferences', 'ca_nhan'])
def preferences_command(message):
    user_id = str(message.from_user.id)
    preferences = load_preferences()
    if user_id in preferences:
        favorites = preferences[user_id].get("favorites", [])
        response = "C√° nh√¢n c·ªßa b·∫°n:\n"
        response += f"- Y√™u th√≠ch: {', '.join([f'{m['symbol']} ({m['type']})' if isinstance(m, dict) else m for m in favorites]) if favorites else 'Ch∆∞a c√≥'}\n"
        response += "Mu·ªën x√≥a h·∫øt? G√µ /xoa_ca_nhan nha! üòÑ"
    else:
        response = "Ch∆∞a c√≥ th√¥ng tin c√° nh√¢n n√†o! Th·ª≠ /thoitiet ho·∫∑c /thitruong ƒë·ªÉ l∆∞u nha! üòé"
    save_message(user_id, message.text, response)
    bot.reply_to(message, response)

@bot.message_handler(commands=['reset_preferences', 'xoa_ca_nhan'])
def reset_preferences_command(message):
    user_id = str(message.from_user.id)
    preferences = load_preferences()
    if user_id in preferences:
        del preferences[user_id]
        save_preferences(preferences)
        response = "X√≥a h·∫øt th√¥ng tin c√° nh√¢n r·ªìi nha! üòÑ B·∫Øt ƒë·∫ßu l·∫°i n√†o!"
    else:
        response = "Ch∆∞a c√≥ g√¨ ƒë·ªÉ x√≥a c·∫£! üòÖ"
    save_message(user_id, message.text, response)
    bot.reply_to(message, response)

@bot.message_handler(commands=['status', 'trang_thai'])
def status_command(message):
    user_id = str(message.from_user.id)
    response = "Tui v·∫´n s·ªëng kh·ªèe! üòé API th·ªùi ti·∫øt, th·ªã tr∆∞·ªùng v√† LLM ƒëang ho·∫°t ƒë·ªông. Mu·ªën th·ª≠ h·ªèi g√¨ kh√¥ng?"
    save_message(user_id, message.text, response)
    bot.reply_to(message, response)

@bot.message_handler(func=lambda message: True)
def handle_all_messages(message):
    user_id = str(message.from_user.id)
    user_name = message.from_user.first_name
    text = message.text.lower()
    sentiment, sentiment_response = analyze_sentiment(message.text)
    intent = extract_intent(message.text)
    
    logging.info(f"User: {user_name}, Message: {message.text}, Sentiment: {sentiment}, Intent: {intent}")
    
    if intent == "time":
        current_time = datetime.now(VN_TIMEZONE).strftime("%H:%M:%S")
        response = f"Ch√†o {user_name}, b√¢y gi·ªù l√† {current_time}. L√†m g√¨ ti·∫øp n√†o? üòé {sentiment_response}"
    elif intent == "weather":
        city = user_context.get(user_id, {}).get("last_city") or (load_preferences().get(user_id, {}).get("favorites", [None])[-1] if isinstance(load_preferences().get(user_id, {}).get("favorites", [None])[-1], str) else None)
        if city:
            weather_info = get_weather(city)
            response = f"Th·ªùi ti·∫øt {city}: {weather_info}. Mu·ªën xem n∆°i kh√°c kh√¥ng? üå§Ô∏è {sentiment_response}"
        else:
            response = f"Ch∆∞a ch·ªçn th√†nh ph·ªë n√®! Th·ª≠ /thoitiet H√† N·ªôi ƒëi! üòÑ {sentiment_response}"
    elif intent == "joke":
        response = f"{get_joke()}. Mu·ªën th√™m kh√¥ng vui? üòú {sentiment_response}"
    elif intent == "market":
        last_favorite = user_context.get(user_id, {}).get("last_favorite") or load_preferences().get(user_id, {}).get("favorites", [None])[0]
        if last_favorite:
            market_data = get_market_data(last_favorite["symbol"], last_favorite["type"])
            response = f"Th·ªã tr∆∞·ªùng {last_favorite['symbol']}: {market_data}. Xem c√°i kh√°c xem! üìä {sentiment_response}"
        else:
            response = f"Mu·ªën xem c·ªï phi·∫øu hay crypto? Th·ª≠ /thitruong BTC crypto nha! üòé {sentiment_response}"
    else:
        llm_response = get_llm_response(message.text, user_id)
        response = f"{llm_response} \nH·ªèi ti·∫øp ƒëi nha, {user_name}! üòÑ {sentiment_response}"
    
    save_message(user_id, message.text, response)
    bot.reply_to(message, response)

if __name__ == "__main__":
    print("Bot is running...")
    cleanup_old_messages()
    try:
        bot.polling()
    except Exception as e:
        logging.error(f"Bot polling error: {str(e)}")
        print(f"Error: {str(e)}. Check bot.log for details.")